# Практическое задание 2: Пул потоков и асинхронные операции

## Структура проекта

Проект состоит включает классы:

- **Program.cs**  
  генерация данных, последовательная обработка, запуск параллельных реализаций (ThreadPool, TAP, APM), замер времени выполнения и вывод статистики.

- **TaskProcessor.cs**  
  класс, инкапсулирующий логику обработки данных:
  - `ProcessDataWithThreadPool(decimal[] data)` – обработка с использованием ThreadPool  
  - `ProcessDataAsync(decimal[] data)` – обработка с использованием TAP (Task-based Asynchronous Pattern)  
  - `BeginProcessData(decimal[] data, AsyncCallback callback, object state)` /  
    `EndProcessData(IAsyncResult asyncResult)` – реализация APM (Asynchronous Programming Model)

- **AsyncLogger.cs**  
  вспомогательный класс для асинхронного логирования:
  - `LogAsync(string message)` – асинхронная запись в файл (TAP, FileOptions.Asynchronous)  
  - `LogWithCallback(string message, Action callback)` – запись в файл с использованием APM и callback

---

## Реализованные подходы

### 1. Последовательная обработка
- используется как базовый вариант;
- выполняет те же вычисления, что и параллельные версии;

### 2. ThreadPool
- массив делится на 8 логических частей;
- каждая часть обрабатывается рабочим потоком из пула потоков;
- синхронизация завершения задач выполняется через `CountdownEvent`;
- результаты собираются в общий массив без гонок данных.

### 3. TAP (Task-based Asynchronous Pattern)
- используется `Task.Run` для запуска обработки частей массива в фоновых задачах;
- ожидание завершения всех задач выполняется через `Task.WhenAll`;
- ошибки обрабатываются через `Task.Exception`.

### 4. APM (Asynchronous Programming Model)
- реализованы методы `BeginProcessData` и `EndProcessData`;
- используется собственная реализация `IAsyncResult`;
- работа выполняется через ThreadPool без применения `async/await`;
- завершение сигнализируется через `AsyncCallback` и `WaitHandle`.
---

## Параметры тестирования

- размер массива: 10 000 000 элементов  
- тип данных: `decimal`  
- диапазон значений: 1.0 – 1000.0  
- генератор случайных чисел: `Random(42)` для воспроизводимости  
- процессор: Intel Core i3-5000U, 2.00 GHz  
- режим сборки: Release  
- измерение времени: `Stopwatch`

---

## Результаты тестирования

```
Размер данных: 10000000 элементов
Последовательная обработка: 3893 мс
ThreadPool обработка: 1705 мс
TAP обработка: 3280 мс
APM обработка: 1951 мс
Ускорение ThreadPool: 2,28x
Ускорение TAP: 1,19x
Ускорение APM: 2,00x
Результаты совпадают: Да
```

## Анализ результатов

1. ThreadPool  показал наилучшее ускорение (2.28x) по сравнению с последовательной обработкой.  
   Используются минимальные накладные расходы выполняется прямое использование пула потоков без дополнительной абстракции.

2. APM показал ускорение около 2.0x.  
   Модель APM даёт меньше накладных расходов, чем TAP, но сложнее в реализации

3. TAP показал наименьшее ускорение (1.19x).  

4. влияние аппаратной платформы  
   тесты выполнялись на процессоре Intel Core i3-5000U (2.00 GHz, мобильный CPU с ограниченным энергопотреблением).  
   на таких процессорах ускорение параллельных алгоритмов ограничено:
   - меньшим количеством физических ядер,
   - более низкой пропускной способностью памяти,
   - конкуренцией потоков за кэш и ресурсы процессора.
   при запуске на более производительных многоядерных CPU ожидается более выраженный выигрыш от параллельной обработки.

---

## Выводы

- использование ThreadPool позволяет получить заметное ускорение по сравнению с последовательной обработкой при работе с большими массивами данных;
- APM даёт близкий по производительности результат, но уступает ThreadPool по удобству и читаемости кода;
- TAP является наиболее современным и удобным шаблоном разработки, но имеет дополнительные накладные расходы;
- результаты подтверждают, что выбор асинхронного шаблона влияет не только на архитектуру кода, но и на фактическое время выполнения.

---
